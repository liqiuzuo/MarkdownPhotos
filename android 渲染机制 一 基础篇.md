# Android 渲染机制 一

## 前言
> 此章节内容主要引自于 [Google 发布 Android 性能优化典范 - 开源中国社区](http://www.oschina.net/news/60157/android-performance-patterns?sid=07vbqo00ovnh233e0ain6ue5a6)  
> 该章节的主要目的是用于归纳总结 另：[google 原视频链接](https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE)

## 原理篇

> 大家自己编写App的时候，有时会感觉界面卡顿，尤其是自定义View的时候，大多数是因为布局的层次过多，存在不必要的绘制，或者onDraw等方法中过于耗时。那么究竟需要多快，才能给用户一个流畅的体验呢？   

&#160; &#160; &#160; &#160;那么就需要简单了解下Android的渲染机制，一图胜千言：![](http://static.oschina.net/uploads/img/201503/04080416_dgEb.png)    
&#160; &#160; &#160; &#160;Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，那么整个过程如果保证在16ms以内就能达到一个流畅的画面。那么如果操作超过了16ms就会发生下面的情况
![](http://static.oschina.net/uploads/img/201503/04080416_cWwX.png) 

### 1.Why 16ms?
> 在正式解释之前，先引出两个基本概念：  
&#160; &#160; &#160; &#160;1. Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的固定参数，例如60Hz。   
&#160; &#160; &#160; &#160;2. Frame Rate：代表了GPU在一秒内绘制操作的帧数，例如30fps，60fps。    

&#160; &#160; &#160; &#160;**我们通常都会提到60fps与16ms，可是知道为何会是以程序是否达到60fps来作为App性能的衡量标准吗？这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新。**    
&#160; &#160; &#160; &#160;12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。但是低于30fps是无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果，当然超过60fps是没有必要的。   
&#160; &#160; &#160; &#160;**开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。**    


### 2.UI -> GPU&CPU？
>了解 Android 为什么使用16ms刷新页面之后，那么渲染过程到底是如何完成的呢？activity的画面是如何绘制到屏幕上的？那些复杂的XML布局文件又是如何能够被识别并绘制出来的？ CPU & GPU 在其中有起到什么作用呢？

![](http://static.oschina.net/uploads/img/201503/04080428_b0BJ.png)

&#160; &#160; &#160; &#160;**Resterization栅格化**是绘制那些Button，Shape，Path，String，Bitmap等组件最基础的操作。它把那些组件拆分到不同的像素上进行显示。这是一个很费时的操作，GPU的引入就是为了加快栅格化的操作。   
&#160; &#160; &#160; &#160;**CPU**负责把UI组件计算成Polygons，Texture纹理，然后交给**GPU**进行栅格化渲染。

![](http://static.oschina.net/uploads/img/201503/04080429_tar2.png)  

&#160; &#160; &#160; &#160;然而每次从CPU转移到GPU是一件很麻烦的事情，所幸的是OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作。所以如果你更新了GPU所hold住的纹理内容，那么之前保存的状态就丢失了   
&#160; &#160; &#160; &#160;在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到 GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图 片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲 染，回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则是一个更加复杂的操作流程。   
&#160; &#160; &#160; &#160;为了能够使得App流畅，我们需要在每一帧16ms以内处理完所有的CPU与GPU计算，绘制，渲染等等操作。

### 3.布局刷新

> 了解到 CPU 和 GPU 如何配合工作绘制 UI 后，Android 系统是如何处理 UI 组件的更新操作的？ 

&#160; &#160; &#160; &#160;通常来说，Android需要把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。   
&#160; &#160; &#160; &#160;在某个View第一次需要被渲染时，DisplayList会因此而被创建，当这个View要显示到屏幕上时，我们会执行GPU的绘制指令来进行渲染。如果你在后续有执行类似移动这个View的位置等操作而需要再次渲染这个View时，我们就仅仅需要额外操作一次渲染指令就够了。然而如果你修改了 View中的某些可见组件，那么之前的DisplayList就无法继续使用了，我们需要回头重新创建一个DisplayList并且重新执行渲染指令并 更新到屏幕上。    
&#160; &#160; &#160; &#160;需要注意的是：任何时候View中的绘制内容发生变化时，都会重新执行创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大 到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。我们需要尽量减少Overdraw。

![](http://static.oschina.net/uploads/img/201503/04080430_VRI7.png)



